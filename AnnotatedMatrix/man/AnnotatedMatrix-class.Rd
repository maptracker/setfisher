% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AnnotatedMatrix.R
\docType{class}
\name{AnnotatedMatrix-class}
\alias{AnnotatedMatrix-class}
\alias{AnnotatedMatrix}
\title{Annotated Matrix}
\description{
Annotated sparse matrix for capturing query lists, identifier
mappings and ontology lookups
}
\details{
\preformatted{
## Object creation
AnnotatedMatrix( help=FALSE ) # Show this help

myAnnMat <- AnnotatedMatrix( file=NA, params=NA, autofilter=TRUE, ...)

myAnnMat$help()                 # High-level help
myAnnMat$ANYMETHOD( help=TRUE ) # Detailed help for all methods
}

AnnotatedMatrix is a heavy wrapper around the Matrix package, in
particular the sparse matrix dgTMatrix class. It was built with an
eye toward using the MatrixMarket file format, an efficient but
unfortunately simple (no structured annotation) file format. This
package will parse information from the comments ('%') of
MatrixMarket files to generate rich objects for enhanced filtering
and reporting.

The driving motivation for the package is to support enrichment
analysis (Fisher's exact test) in a reproducible research
framework. The package is also very well suited for identifier
mapping (for example, gene symbols to gene accessions).
}
\section{Fields}{

\describe{
\item{\code{file}}{Path to file the matrix was loaded from}

\item{\code{fromRDS}}{Logical, true if the loaded file was an RDS object}

\item{\code{log}}{EventLogger object holding log (activity) entries}

\item{\code{matrixRaw}}{The Matrix object as loaded from the file, will
not be altered by the object.}

\item{\code{matrixUse}}{The Matrix object after manipulation by any
applied filters}

\item{\code{matrixMD}}{data.table holding metadata associated with the
matrix}

\item{\code{lvlVal}}{Character array of level names for factor matrices}

\item{\code{filterLog}}{data.frame storing filtering events that transpire
during the pruning of matrices prior to analysis.}

\item{\code{setFilters}}{Human- and machine-readable character vector of
filters that have been applied}

\item{\code{rowChanges}}{Named character vector of any row names that
needed changing. Values are the original name, names are the
names after processing with make.names() (if valid = TRUE) or
make.unique() if (valid = FALSE)}

\item{\code{colChanges}}{As per rowChanges, but for column names}
}}

\section{Methods}{

\describe{
\item{\code{appliedFilters(new = NULL)}}{\preformatted{
Filters applied to matrix so far, represented as text that can be read
both by humans and computationally.
      new - Provide new filters to apply, using the same format.
            Designed to allow a snapshot of the filter state to be
            reapplied to the matrix after a $reset()
}}

\item{\code{as.gmt(obj = NULL, transpose = FALSE, file = NULL, ...)}}{\preformatted{
Converts matrix into a block of GMT-formatted text
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well. Alternatively a Matrix can be provided.
  transpose - Default FALSE, which will presume that the rows are sets. If TRUE,
              then columns will be taken as sets
       file - Default NULL, if defined then the output will be written to that
              path
}}

\item{\code{autoFilter(recursive = TRUE, verbose = TRUE, help = FALSE)}}{Automatically apply filters defined in the parameters}

\item{\code{cCounts(obj = NULL, ...)}}{\preformatted{
Return an integer vector of non-zero rows for each column
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well (so you can select the raw matrix if
              desired)
}}

\item{\code{cNames(new = NULL, raw = FALSE, reason = NA, help = FALSE)}}{Get/set colnames for the matrix}

\item{\code{filterByFactorLevel(x, keep = TRUE, ignore.case = TRUE,
  filterEmpty = FALSE, reason = NA)}}{\preformatted{
For factor matrices, filter out values by factor level.
Returns the number of cells zeroed (filtered) out.
          x - A vector of factor levels to remove, either integers or
              character values
       keep - Default TRUE, which will result in keeping only the values
              that match x. If FALSE, the values in x are excluded.
 ignore.case - Default TRUE, which allows factor levels to be match
              while disregarding capitalization
 filterEmpty - Default FALSE; If true, then the matrix will be 'shrunk' to
              remove rows and columns that are only zeros
     reason - Default NA; If specified, a text value that will be added to
              the $filterLog under the 'reason' column
}}

\item{\code{filterByMetadata(key, val, MARGIN = NULL, type = "like", op = "or",
  reason = NA)}}{\preformatted{
Zero out rows or columns that have metadata matching certain values
Returns the number of cells zeroed (filtered) out.
        key - The metadata key/tag/column to match
        val - The value(s) to match
     MARGIN - Default NULL, which will test matched IDs against both rows
              and columns. Can also be 1, row, 2 or col
       type - Default 'like'. Recognized values are:
                like = Finds matches of word/phrase anywhere in text
                regexp = Per 'like', but will interpret as regular expression
                equal  = Finds only full exact matches
              In addition, 'case' can be added to any type to force
              case-sensitive matches.
         op - Default 'or', which will count a match if any of the values
              Alternative is 'and', which requires all values to match.
              'any' and 'all' are also acceptible.
     reason - Default NA; If specified, a text value that will be added to
              the $filterLog under the 'reason' column
}}

\item{\code{filterByScore(min = NA, max = NA, filterEmpty = FALSE, reason = NA)}}{\preformatted{
Apply filters to the current matrix to zero-out cells failing thresholds.
Returns the count of (cells,rows,cols) zeroed (filtered) out.
        min - Minimum allowed value. Cells below this will be set to zero
        max - Maximum allowed value. Cells above it will be set to zero
 filterEmpty - Default FALSE; If true, then the matrix will be 'shrunk' to
              remove rows and columns that are only zeros
     reason - Default NA; If specified, a text value that will be added to
              the $filterLog under the 'reason' column
}}

\item{\code{filterSummary(reason = TRUE)}}{\preformatted{
Tallies number of filtered objects (generally cells) by filter criteria
and optionally reason. Returns a data frame
   reason - Default TRUE, which includes the reason text in the count
            grouping
}}

\item{\code{help(color = NULL)}}{\preformatted{
Show compact help information about the object
      color - Should output be colorized. Default NULL, which checks
              $color()
}}

\item{\code{is.factor()}}{\preformatted{
TRUE if the matrix is a pseudo-factor (levels have been defined),
otherwise FALSE
}}

\item{\code{levels(asFactor = FALSE)}}{\preformatted{
Returns factor levels, if appropriate. If not, returns NULL
 asFactor - Default FALSE, which will return an ordered character vector of the
            level values (names). If true, a factor will be returned with
            appropriate levels assigned
}}

\item{\code{map(input = NULL, via = NULL, format = "data.frame", ignore.case = TRUE,
  keep.best = FALSE, column.func = max, collapse = NULL,
  collapse.name = NULL, collapse.token = ",", collapse.score = NULL,
  collapse.factor = NULL, integer.factor = FALSE, add.metadata = TRUE,
  warn = TRUE, append.to = NULL, append.col = 1L, help = FALSE)}}{\preformatted{
Provide a list of IDs, and map/pivot it from one dimension of the matrix
to the other, following 'connections' defined by non-zero cells. Returns
a data.frame with Input and Output columns, plus Score and/or Factor columns.

If collapse='out', rownames will be set to the Output column. Otherwise,
if an input ID results in a unique row, the rowname will be that input ID.
Other-otherwise, the rowname will be the input ID plus '#1', '#2' etc for
each row with that ID. Non-unique input IDs will never generate an
unaltered rowname.

      input - A vector of 'input' IDs. Required, unless append.to is set, in
              which case it will be taken from that table using append.col
        via - Specify if the input matches the 'rows' or 'columns' of the
              matrix. If NULL (default) then your input will be compared to
              the row and column names, and the one with the most matches
              will be chosen (defaulting to 'row' in the event of equal matches)
     format - Default 'data.frame', specifies the output format. Can also be:
                 Vector: Will return a named character vector, with values
                         corresponding to $Output and names as $Input
 ignore.case - Default TRUE, which ignores the capitilazation of IDs
  keep.best - Default FALSE. If TRUE, then only the top-scored cell(s) will
              be kept
 column.func - Default max. If ignore.case is true, it is possible that an
              input ID can match multiple matrix IDs. In this case, multiple
              matching rows will be returned for one ID. column.func is
              applied to reduce this to a single row.
   collapse - Default FALSE, which will cause every pairwise connection to be
              reported. If 'in', then the Input column of the data.frame will be
              unique - any input value that results in multiple output values
              will result in the Output IDs and Score being 'collapsed' to a
              single value (see the collapse.* options below). A value of 'out'
              will do the same, but causes the Output column to be unique, and
              Input and Score are collapsed.
 collapse.name - Default NULL, which will cause multiple names to be
              concatenated into a single value using paste(). Alternatively,
              a user function can be provided. This package also includes the
              crude utility function takeLowestThing() (see documentation).
 collapse.token - Default ',', a string used to concatenate collapsed IDs
              when using paste (collapse.name=NULL)
 collapse.score - Default NULL. Optional function to apply to the $Score
              column when two or more rows are being collapsed into one. The
              function should take a numeric vector as input and return a
              single numeric value. If NULL, the function will be mean(),
              unless the matrix is a pseudo-factor, in which case the object
              method $.autoLevel() will be used. This will generate new
              'hybrid' factors as needed. collapse.token will be used as the
              string to join factors into a new level name.
 integer.factor - Default FALSE, which will cause the Score column to be absent
              and a Factor column (with level values as characters) to be
              present instead. If TRUE then ONLY a Score column (representing
              integer values, perhaps including new likely-meaningless hybrid
              values from $.autoLevel()) will be added. If NULL, then both
              Score and Factor columns are present.
 add.metadata - Default TRUE, which will add all metadata columns that have
              at least some information. FALSE will prevent adding metadata,
              and a character vector will add those specific columns (which
              is up to the user to confirm they exist in the metadata store)
       warn - Default TRUE, which will show warning text if matches failed to
              be made for the input. This information is also always captured
              in attributes attached to the returned data.frame
  append.to - Default NULL. If a data.frame-compliant object, it will become
              the return value, with the mapped columns being added on.
              If collapse='out' then the Output column will be used to
              merge, otherwise the Input column will be utilized. The merge
              column from the provided data.frame is set with append.col
 append.col - The column to use in append.to for merging. Default is 1,
              can provide another column number or name.
}}

\item{\code{matObj(raw = FALSE, transpose = FALSE, help = FALSE)}}{Return the current filtered state of the dgTMatrix sparse matrix}

\item{\code{metadata(id = NULL, key = NULL, na.rm = TRUE, drop = TRUE,
  verbose = TRUE)}}{\preformatted{
Select metadata by id, key or both
         id - Optional vector of IDs to query. If not provided, all IDs
              will be returned. Bear in mind that the metadata holds both
              row and column IDs mixed together
        key - Optional vector of key/tag names, if not provided then all
              available ones will be returned.
      na.rm - Default TRUE, which will remove NA values from returned
              results. Does not apply when both id and key are specified.
       drop - Default TRUE. If FALSE, the return value will be a data.table
              If TRUE, and zero or one metadata columns are present, then
              a named vector is returned.
    verbose - Default TRUE, which will warn about certain issues
}}

\item{\code{metadata_keys(id = NULL, key = NULL)}}{\preformatted{
Returns a character vector of metadata key names (eg 'Description')
}}

\item{\code{nnZero(obj = NULL, ...)}}{\preformatted{
Return the count of non-zero elements in the matrix. This is essentially
the number of 'live connections' currently stored.
cell
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well (so you can select the raw matrix if
              desired)
}}

\item{\code{populatedCols(obj = NULL, ...)}}{\preformatted{
Return a logical vector indicating which columns have at least one non-zero
 cell
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well (so you can select the raw matrix if
              desired)
}}

\item{\code{populatedRows(obj = NULL, ...)}}{\preformatted{
Return a logical vector indicating which rows have at least one non-zero
cell
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well (so you can select the raw matrix if
              desired)
}}

\item{\code{rCounts(obj = NULL, ...)}}{\preformatted{
Return an integer vector of non-zero columns for each row
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well (so you can select the raw matrix if
              desired)
}}

\item{\code{removeEmpty(reason = NA)}}{\preformatted{
Remove all empty rows and columns. Invisibly returns a vector of removed IDs.
     reason - Default NA; If specified, a text value that will be added to
              the $filterLog under the 'reason' column
}}

\item{\code{removeEmptyCols(reason = NA)}}{\preformatted{
Remove all empty columns (those that only contain zeros). Invisibly
returns a vector of removed IDs.
     reason - Default NA; If specified, a text value that will be added
              to the $filterLog under the 'reason' column
}}

\item{\code{removeEmptyRows(reason = NA)}}{\preformatted{
Remove all empty rows (those that only contain zeros). Invisibly returns a
vector of removed IDs.
     reason - Default NA; If specified, a text value that will be added to
              the $filterLog under the 'reason' column
}}

\item{\code{reset(help = FALSE)}}{Reset the matrix to the 'raw' (unfiltered) state}

\item{\code{rNames(new = NULL, raw = FALSE, reason = NA, help = FALSE)}}{Get/set rownames for the matrix}

\item{\code{show(...)}}{\preformatted{
A wrapper for showText(). Will be auto-invoked if an EventLogger
object is evaluated in the shell, UNLESS the object has a higher-
precedence show() function of its own. In that case, use showLog()
to display log contents.
}}
}}

\examples{

## In most circumstances you will provide only a file path, but
## optionally a list of parameters and a flag to turn off autoFilter
## can be provided as well.

## A toy (small) symbol-to-gene mapping matrix is provided with the
## package:
s2e <- AnnotatedMatrix( annotatedMatrixExampleFile() )

s2e$help()         # Compact reminder of fields and methods
s2e                # Summary of loaded object
s2e$map(help=TRUE) # Help for the map() method
AnnotatedMatrix(help=TRUE) # display this help

## Load a toy symbol-to-gene mapping matrix and use it to convert
## some genes to Entrez Gene IDs
demo("geneSymbolMapping", package="AnnotatedMatrix", ask=FALSE)

## Work with different file formats
demo("fileFormats", package="AnnotatedMatrix", ask=FALSE)

## Different approaches to handling non-unique mappings:
demo("managingMultiplicity", package="AnnotatedMatrix", ask=FALSE)

## Working with metadata
demo("workingWithMetadata", package="AnnotatedMatrix", ask=FALSE)

}
