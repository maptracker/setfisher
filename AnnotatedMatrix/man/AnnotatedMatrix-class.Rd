% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AnnotatedMatrix.R
\docType{class}
\name{AnnotatedMatrix-class}
\alias{AnnotatedMatrix-class}
\alias{AnnotatedMatrix}
\title{Annotated Matrix}
\description{
Annotated sparse matrix for capturing query lists, identifier
mappings and ontology lookups
}
\details{
\preformatted{
## Object creation
AnnotatedMatrix( help=FALSE ) # Show this help

myAnnMat <- AnnotatedMatrix( file=NA, params=NA, autofilter=TRUE, ...)

myAnnMat$help()                 # High-level help
myAnnMat$ANYMETHOD( help=TRUE ) # Detailed help for all methods
}

AnnotatedMatrix is a heavy wrapper around the Matrix package, in
particular the sparse matrix dgTMatrix class. It was built with an
eye toward using the MatrixMarket file format, an efficient but
unfortunately simple (no structured annotation) file format. This
package will parse information from the comments ('%') of
MatrixMarket files to generate rich objects for enhanced filtering
and reporting.

The driving motivation for the package is to support enrichment
analysis (Fisher's exact test) in a reproducible research
framework. The package is also very well suited for identifier
mapping (for example, gene symbols to gene accessions).
}
\section{Fields}{

\describe{
\item{\code{file}}{Path to file the matrix was loaded from}

\item{\code{fromRDS}}{Logical, true if the loaded file was an RDS object}

\item{\code{log}}{EventLogger object holding log (activity) entries}

\item{\code{matrixRaw}}{The Matrix object as loaded from the file, will
not be altered by the object.}

\item{\code{matrixUse}}{The Matrix object after manipulation by any
applied filters}

\item{\code{matrixMD}}{data.table holding metadata associated with the
matrix}

\item{\code{lvlVal}}{Character array of level names for factor matrices}

\item{\code{filterLog}}{data.frame storing filtering events that transpire
during the pruning of matrices prior to analysis.}

\item{\code{setFilters}}{Human- and machine-readable character vector of
filters that have been applied}

\item{\code{rowChanges}}{Named character vector of any row names that
needed changing. Values are the original name, names are the
names after processing with make.names() (if valid = TRUE) or
make.unique() if (valid = FALSE)}

\item{\code{colChanges}}{As per rowChanges, but for column names}
}}

\section{Methods}{

\describe{
\item{\code{appliedFilters(new = NULL)}}{\preformatted{
Filters applied to matrix so far, represented as text that can be read
both by humans and computationally.
      new - Provide new filters to apply, using the same format.
            Designed to allow a snapshot of the filter state to be
            reapplied to the matrix after a $reset()
}}

\item{\code{as.gmt(obj = NULL, transpose = FALSE, file = NULL, ...)}}{\preformatted{
Converts matrix into a block of GMT-formatted text
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well. Alternatively a Matrix can be provided.
  transpose - Default FALSE, which will presume that the rows are sets. If TRUE,
              then columns will be taken as sets
       file - Default NULL, if defined then the output will be written to that
              path
}}

\item{\code{autoFilter(recursive = TRUE, verbose = TRUE, help = FALSE)}}{Automatically apply filters defined in the parameters}

\item{\code{cCounts(obj = NULL, help = FALSE, ...)}}{Return the counts of non-zero rows for each column}

\item{\code{cNames(new = NULL, raw = FALSE, reason = NA, help = FALSE)}}{Get/set colnames for the matrix}

\item{\code{filterByFactorLevel(x, keep = TRUE, ignore.case = TRUE,
  filterEmpty = FALSE, reason = NA, help = FALSE)}}{Zero-out cells in the matrix that fail factor criteria}

\item{\code{filterByMetadata(key, val, MARGIN = NULL, keep = TRUE, type = "like",
  op = "or", filterEmpty = FALSE, reason = NA, help = FALSE)}}{Zero-out rows or columns that match metadata criteria}

\item{\code{filterByScore(min = NA, max = NA, filterEmpty = FALSE, reason = NA,
  help = FALSE)}}{Filter matrix cells by simple numeric tests}

\item{\code{filterSummary(reason = TRUE)}}{\preformatted{
Tallies number of filtered objects (generally cells) by filter criteria
and optionally reason. Returns a data frame
   reason - Default TRUE, which includes the reason text in the count
            grouping
}}

\item{\code{help(color = NULL)}}{\preformatted{
Show compact help information about the object
      color - Should output be colorized. Default NULL, which checks
              $color()
}}

\item{\code{is.factor()}}{\preformatted{
TRUE if the matrix is a pseudo-factor (levels have been defined),
otherwise FALSE
}}

\item{\code{levels(asFactor = FALSE)}}{\preformatted{
Returns factor levels, if appropriate. If not, returns NULL
 asFactor - Default FALSE, which will return an ordered character vector of the
            level values (names). If true, a factor will be returned with
            appropriate levels assigned
}}

\item{\code{map(input = NULL, via = NULL, format = "data.frame", ignore.case = TRUE,
  keep.best = FALSE, column.func = max, collapse = NULL,
  collapse.name = NULL, collapse.token = ",", collapse.score = NULL,
  integer.factor = NULL, add.metadata = TRUE, warn = TRUE,
  append.to = NULL, append.col = 1L, help = FALSE)}}{Map (convert) names from one dimension of the matrix to the other}

\item{\code{matObj(raw = FALSE, transpose = FALSE, help = FALSE)}}{Return the current filtered state of the dgTMatrix sparse matrix}

\item{\code{metadata(id = NULL, key = NULL, na.rm = TRUE, drop = TRUE,
  verbose = TRUE)}}{\preformatted{
Select metadata by id, key or both
         id - Optional vector of IDs to query. If not provided, all IDs
              will be returned. Bear in mind that the metadata holds both
              row and column IDs mixed together
        key - Optional vector of key/tag names, if not provided then all
              available ones will be returned.
      na.rm - Default TRUE, which will remove NA values from returned
              results. Does not apply when both id and key are specified.
       drop - Default TRUE. If FALSE, the return value will be a data.table
              If TRUE, and zero or one metadata columns are present, then
              a named vector is returned.
    verbose - Default TRUE, which will warn about certain issues
}}

\item{\code{metadata_keys(id = NULL, key = NULL)}}{\preformatted{
Returns a character vector of metadata key names (eg 'Description')
}}

\item{\code{nnZero(obj = NULL, help = FALSE, ...)}}{Return the count of non-zero elements in the matrix}

\item{\code{populatedCols(obj = NULL, help = FALSE, ...)}}{Determine which columns have at least one non-zero assignment}

\item{\code{populatedRows(obj = NULL, help = FALSE, ...)}}{Determine which rows have at least one non-zero assignment}

\item{\code{rCounts(obj = NULL, help = FALSE, ...)}}{Return the counts of non-zero columns for each row}

\item{\code{removeEmpty(reason = NA, help = FALSE)}}{Remove all rows and columns that consist only of zeroes}

\item{\code{removeEmptyCols(reason = NA, help = FALSE)}}{Remove all rows that consist only of zeroes}

\item{\code{removeEmptyRows(reason = NA, help = FALSE)}}{Remove all rows that consist only of zeroes}

\item{\code{reset(help = FALSE)}}{Reset the matrix to the 'raw' (unfiltered) state}

\item{\code{rNames(new = NULL, raw = FALSE, reason = NA, help = FALSE)}}{Get/set rownames for the matrix}

\item{\code{show(...)}}{\preformatted{
A wrapper for showText(). Will be auto-invoked if an EventLogger
object is evaluated in the shell, UNLESS the object has a higher-
precedence show() function of its own. In that case, use showLog()
to display log contents.
}}
}}

\examples{

## In most circumstances you will provide only a file path, but
## optionally a list of parameters and a flag to turn off autoFilter
## can be provided as well.

## A toy (small) symbol-to-gene mapping matrix is provided with the
## package:
s2e <- AnnotatedMatrix( annotatedMatrixExampleFile() )

s2e$help()         # Compact reminder of fields and methods
s2e                # Summary of loaded object
s2e$map(help=TRUE) # Help for the map() method
AnnotatedMatrix(help=TRUE) # display this help

## Load a toy symbol-to-gene mapping matrix and use it to convert
## some genes to Entrez Gene IDs
demo("geneSymbolMapping", package="AnnotatedMatrix", ask=FALSE)

## Work with different file formats
demo("fileFormats", package="AnnotatedMatrix", ask=FALSE)

## Different approaches to handling non-unique mappings:
demo("managingMultiplicity", package="AnnotatedMatrix", ask=FALSE)

## Working with metadata
demo("workingWithMetadata", package="AnnotatedMatrix", ask=FALSE)

}
