% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AnnotatedMatrix.R
\docType{class}
\name{AnnotatedMatrix-class}
\alias{AnnotatedMatrix-class}
\alias{AnnotatedMatrix}
\title{Annotated Matrix}
\description{
Annotated sparse matrix for capturing query lists, identifier
mappings and ontology lookups
}
\details{
\preformatted{
## Object creation
AnnotatedMatrix( help=TRUE ) # Show this help

## In general:
myAnnMat <- AnnotatedMatrix( file=NA, params=NA, autofilter=TRUE, ...)
## Specific toy example matrix:
myAnnMat <- AnnotatedMatrix( annotatedMatrixExampleFile() )

myAnnMat$help()                 # High-level help
myAnnMat$ANYMETHOD( help=TRUE ) # Each method has detailed help available
}

AnnotatedMatrix is a heavy wrapper around the Matrix package, in
particular the sparse matrix dgTMatrix class. It was built with an
eye toward using the MatrixMarket file format, an efficient but
unfortunately simple (no structured annotation) file format. This
package will parse information from the comments ('%') of
MatrixMarket files to generate rich objects for enhanced filtering
and reporting.

The driving motivation for the package is to support enrichment
analysis (Fisher's exact test) in a reproducible research
framework. The package is also very well suited for identifier
mapping (for example, gene symbols to gene accessions).
}
\section{Fields}{

\describe{
\item{\code{file}}{Path to file the matrix was loaded from}

\item{\code{fromRDS}}{Logical, true if the loaded file was an RDS object}

\item{\code{log}}{EventLogger object holding log (activity) entries}

\item{\code{matrixRaw}}{The Matrix object as loaded from the file, will
not be altered by the object.}

\item{\code{matrixUse}}{The Matrix object after manipulation by any
applied filters}

\item{\code{matrixMD}}{data.table holding metadata associated with the
matrix}

\item{\code{lvlVal}}{Character array of level names for factor matrices}

\item{\code{filterLog}}{data.frame storing filtering events that transpire
during the pruning of matrices prior to analysis.}

\item{\code{setFilters}}{Human- and machine-readable character vector of
filters that have been applied}

\item{\code{rowChanges}}{Named character vector of any row names that
needed changing. Values are the original name, names are the
names after processing with make.unique()}

\item{\code{colChanges}}{As per rowChanges, but for column names}

\item{\code{colDefs}}{list of definitions for metadata columns}
}}

\section{Methods}{

\describe{
\item{\code{appliedFilters(new = NULL, help = FALSE)}}{Get applied filters as a vector of readable/parsable strings}

\item{\code{as.gmt(obj = NULL, transpose = FALSE, file = NULL, help = FALSE, ...)}}{Convert the active matrix into GMT text representation}

\item{\code{as.ijx(file = NULL, sep = "\\t", obj = NULL, help = FALSE)}}{Serialize matrix as IJX row/col/val three-column format}

\item{\code{as.mtx(obj = NULL, file = NULL, help = FALSE, ...)}}{Convert the active matrix into Matrix Market text representation}

\item{\code{autoFilter(recursive = TRUE, verbose = TRUE, help = FALSE)}}{Automatically apply filters defined in the parameters}

\item{\code{cCounts(obj = NULL, help = FALSE, ...)}}{Return the counts of non-zero rows for each column}

\item{\code{cNames(new = NULL, raw = FALSE, nonzero = FALSE, reason = NA,
  help = FALSE)}}{Get/set colnames for the matrix}

\item{\code{filterByCount(MARGIN, min = NULL, max = NULL, relative = TRUE,
  filterEmpty = FALSE, reason = NA, help = FALSE)}}{Filter rows or columns based on number of non-zero connections}

\item{\code{filterByFactorLevel(x, keep = TRUE, ignore.case = TRUE,
  filterEmpty = FALSE, reason = NA, help = FALSE)}}{Zero-out cells in the matrix that fail factor criteria}

\item{\code{filterById(id, MARGIN = NULL, keep = FALSE, ignore.case = TRUE,
  exact = TRUE, filterEmpty = FALSE, reason = NA, help = FALSE)}}{Filter rows or columns based on specific IDs}

\item{\code{filterByMetadata(key, val, MARGIN = NULL, keep = TRUE, type = "like",
  op = "or", filterEmpty = FALSE, reason = NA, help = FALSE)}}{Zero-out rows or columns that match metadata criteria}

\item{\code{filterByScore(min = NA, max = NA, filterEmpty = FALSE, reason = NA,
  help = FALSE)}}{Filter matrix cells by simple numeric tests}

\item{\code{filterSummary(reason = TRUE, help = FALSE)}}{Human-readable overview of filters and counts of rows/cols removed}

\item{\code{help(color = NULL, help = FALSE)}}{Display high-level help about all object methods}

\item{\code{initialize(params = NA, paramDefinitions = NA, help = FALSE, ...)}}{Create a new ParamSetI object; Invoked with ParamSetI(...)}

\item{\code{is.factor(help = FALSE)}}{TRUE if the matrix is a pseudo-factor, otherwise FALSE}

\item{\code{levels(asFactor = FALSE, help = FALSE)}}{Returns factor levels, if appropriate. If not, returns NULL}

\item{\code{map(input = NULL, via = NULL, format = "data.frame", ignore.case = TRUE,
  keep.best = FALSE, column.func = max, collapse = NULL,
  collapse.name = NULL, collapse.token = ",", collapse.score = NULL,
  integer.factor = NULL, add.metadata = TRUE, input.metadata = FALSE,
  warn = TRUE, append.to = NULL, append.col = 1L, recurse = 0,
  in.name = "Input", out.name = "Output", score.name = NULL,
  prefix.metadata = TRUE, help = FALSE)}}{Map (convert) names from one dimension of the matrix to the other}

\item{\code{matObj(raw = FALSE, transpose = FALSE, help = FALSE)}}{Return the current filtered state of the dgTMatrix sparse matrix}

\item{\code{matrixText(pad = "", useObj = NULL, fallbackVar = NULL, compact = FALSE,
  color = NULL, help = FALSE)}}{Generate a compact text summary of the object, used by show()}

\item{\code{melt(obj = NULL, file = NULL, named.dims = TRUE, help = FALSE, ...)}}{Represent matrix as data.frame with three rows: Row, Col, Val}

\item{\code{metadata(id = NULL, key = NULL, na.rm = TRUE, drop = TRUE,
  verbose = TRUE, help = FALSE)}}{Recover metadata for specific IDs and/or columns}

\item{\code{metadata_keys(help = FALSE)}}{Get all metadata keys as a character vector}

\item{\code{nnZero(obj = NULL, help = FALSE, ...)}}{Return the count of non-zero elements in the matrix}

\item{\code{populatedCols(obj = NULL, help = FALSE, ...)}}{Determine which columns have at least one non-zero assignment}

\item{\code{populatedRows(obj = NULL, help = FALSE, ...)}}{Determine which rows have at least one non-zero assignment}

\item{\code{product(mat2, dim1 = NULL, dim2 = NULL, valfunc = NULL, levels = NULL,
  ignore.zero = TRUE, ignore.case = TRUE, help = FALSE)}}{Take a product of this matrix AxB with another BxC to yield AxC}

\item{\code{rCounts(obj = NULL, help = FALSE, ...)}}{Return the counts of non-zero columns for each row}

\item{\code{removeEmpty(reason = NA, help = FALSE)}}{Remove all rows and columns that consist only of zeroes}

\item{\code{removeEmptyCols(reason = NA, help = FALSE)}}{Remove all rows that consist only of zeroes}

\item{\code{removeEmptyRows(reason = NA, help = FALSE)}}{Remove all rows that consist only of zeroes}

\item{\code{reset(help = FALSE)}}{Reset the matrix to the 'raw' (unfiltered) state}

\item{\code{rNames(new = NULL, raw = FALSE, nonzero = FALSE, reason = NA,
  help = FALSE)}}{Get/set rownames for the matrix}

\item{\code{show(...)}}{A wrapper for showLog}
}}

\examples{

## In most circumstances you will provide only a file path, but
## optionally a list of parameters and a flag to turn off autoFilter
## can be provided as well.

## A toy (small) symbol-to-gene mapping matrix is provided with the
## package:
s2e <- AnnotatedMatrix( annotatedMatrixExampleFile() )

s2e$help()         # Compact reminder of fields and methods
s2e                # Summary of loaded object
s2e$map(help=TRUE) # Help for the map() method
AnnotatedMatrix(help=TRUE) # display this help

## Load a toy symbol-to-gene mapping matrix and use it to convert
## some genes to Entrez Gene IDs
demo("geneSymbolMapping", package="AnnotatedMatrix", ask=FALSE)

## Work with different file formats
demo("fileFormats", package="AnnotatedMatrix", ask=FALSE)

## Different approaches to handling non-unique mappings:
demo("managingMultiplicity", package="AnnotatedMatrix", ask=FALSE)

## Working with metadata
demo("workingWithMetadata", package="AnnotatedMatrix", ask=FALSE)

}
