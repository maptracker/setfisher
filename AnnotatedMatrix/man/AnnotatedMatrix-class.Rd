% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AnnotatedMatrix.R
\docType{class}
\name{AnnotatedMatrix-class}
\alias{AnnotatedMatrix-class}
\alias{AnnotatedMatrix}
\title{Annotated Matrix}
\description{
Annotated sparse matrix for capturing query lists, identifier
mappings and ontology lookups
}
\section{Fields}{

\describe{
\item{\code{file}}{Path to file the matrix was loaded from}

\item{\code{fromRDS}}{Logical, true if the loaded file was an RDS object}

\item{\code{log}}{EventLogger object holding log (activity) entries}

\item{\code{matrixRaw}}{The Matrix object as loaded from the file, will
not be altered by the object.}

\item{\code{matrixUse}}{The Matrix object after manipulation by any
applied filters}

\item{\code{matrixMD}}{data.table holding metadata associated with the
matrix}

\item{\code{lvlVal}}{Character array of level names for factor matrices}

\item{\code{filterLog}}{data.frame storing filtering events that transpire
during the pruning of matrices prior to analysis.}

\item{\code{rowChanges}}{Named character vector of any row names that
needed changing. Values are the original name, names are the
names after processing with make.names() (if valid = TRUE) or
make.unique() if (valid = FALSE)}

\item{\code{colChanges}}{As per rowChanges, but for column names}
}}

\section{Methods}{

\describe{
\item{\code{as.gmt(obj = NULL, transpose = FALSE, file = NULL, ...)}}{\preformatted{
Converts matrix into a block of GMT-formatted text
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well. Alternatively a Matrix can be provided.
  transpose - Default FALSE, which will presume that the rows are sets. If TRUE,
              then columns will be taken as sets
       file - Default NULL, if defined then the output will be written to that
              path
}}

\item{\code{cCounts(obj = NULL, ...)}}{\preformatted{
Return an integer vector of non-zero rows for each column
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well (so you can select the raw matrix if
              desired)
}}

\item{\code{cNames(raw = FALSE)}}{\preformatted{
Returns the column names of the Matrix
      raw - Default FALSE, in which case the filtered Matrix (held in field
            'matrixUse') will be used, if available - otherwise the original
            raw matrix will be used.
}}

\item{\code{filterByFactorLevel(x, keep = TRUE, ignore.case = TRUE,
  filterEmpty = FALSE, reason = NA)}}{\preformatted{
For factor matrices, filter out values by factor level.
Returns the number of cells zeroed (filtered) out.
          x - A vector of factor levels to remove, either integers or
              character values
       keep - Default TRUE, which will result in keeping only the values
              that match x. If FALSE, the values in x are excluded.
 ignore.case - Default TRUE, which allows factor levels to be match
              while disregarding capitalization
 filterEmpty - Default FALSE; If true, then the matrix will be 'shrunk' to
              remove rows and columns that are only zeros
     reason - Default NA; If specified, a text value that will be added to
              the $filterLog under the 'reason' column
}}

\item{\code{filterByScore(min = NA, max = NA, filterEmpty = FALSE, reason = NA)}}{\preformatted{
Apply filters to the current matrix to zero-out cells failing thresholds.
Returns the number of cells zeroed (filtered) out.
        min - Minimum allowed value. Cells below this will be set to zero
        max - Maximum allowed value. Cells above it will be set to zero
 filterEmpty - Default FALSE; If true, then the matrix will be 'shrunk' to
              remove rows and columns that are only zeros
     reason - Default NA; If specified, a text value that will be added to
              the $filterLog under the 'reason' column
}}

\item{\code{is.factor()}}{TRUE if the matrix is a pseudo-factor (levels have been defined), otherwise FALSE}

\item{\code{levels(asFactor = FALSE)}}{\preformatted{Returns factor levels, if appropriate. If not, returns NULL
 asFactor - Default FALSE, which will return an ordered character vector of the
            level values (names). If true, a factor will be returned with
            appropriate levels assigned
}}

\item{\code{map(input, via = NULL, format = "data.frame", ignore.case = TRUE,
  keep.best = FALSE, column.func = max, collapse = NULL,
  collapse.name = NULL, collapse.token = ",", collapse.score = NULL,
  collapse.factor = NULL, integer.factor = FALSE, add.metadata = TRUE,
  warn = TRUE)}}{\preformatted{
Provide a list of IDs, and map/pivot it from one dimension of the matrix to the
other, following 'connections' defined by non-zero cells. Returns a data.frame
with Input and Output columns, plus Score and/or Factor columns.
      input - Required, a vector of IDs
        via - Specify if the input matches the 'rows' or 'columns' of the
              matrix. If NULL (default) then your input will be compared to the
              row and column names, and the one with the most matches will be
              chosen (defaulting to 'row' in the event of equal matches)
     format - Default 'data.frame', specifies the output format. Can also be:
                 Vector: Will return a named character vector, with values
                         corresponding to $Output and names as $Input
 ignore.case - Default TRUE, which ignores the capitilazation of IDs
  keep.best - Default FALSE. If TRUE, then only the top-scored cell(s) will
              be kept
 column.func - Default max. If ignore.case is true, it is possible that an
              input ID can match multiple matrix IDs. In this case, multiple
              matching rows will be returned for one ID. column.func is
              applied to reduce this to a single row.
   collapse - Default FALSE, which will cause every pairwise connection to be
              reported. If 'in', then the Input column of the data.frame will be
              unique - any input value that results in multiple output values
              will result in the Output IDs and Score being 'collapsed' to a
              single value (see the collapse.* options below). A value of 'out'
              will do the same, but causes the Output column to be unique, and
              Input and Score are collapsed.
 collapse.name - Default NULL, which will cause multiple names to be
              concatenated into a single value using paste(). Alternatively,
              a user function can be provided. This package also includes the
              crude utility function takeLowestThing() (see documentation).
 collapse.token - Default ',', a string used to concatenate collapsed IDs
              when using paste (collapse.name=NULL)
 collapse.score - Default NULL. Optional function to apply to the $Score
              column when two or more rows are being collapsed into one. The
              function should take a numeric vector as input and return a
              single numeric value. If NULL, the function will be mean(),
              unless the matrix is a pseudo-factor, in which case the object
              method $.autoLevel() will be used. This will generate new
              'hybrid' factors as needed. collapse.token will be used as the
              string to join factors into a new level name.
 integer.factor - Default FALSE, which will cause the Score column to be absent
              and a Factor column (with level values as characters) to be
              present instead. If TRUE then ONLY a Score column (representing
              integer values, perhaps including new likely-meaningless hybrid
              values from $.autoLevel()) will be added. If NULL, then both
              Score and Factor columns are present.
 add.metadata - Default TRUE, which will add all metadata columns that have
              at least some information. FALSE will prevent adding metadata,
              and a character vector will add those specific columns (which
              is up to the user to confirm they exist in the metadata store)
       warn - Default TRUE, which will show warning text if matches failed to
              be made for the input. This information is also always captured
              in attributes attached to the returned data.frame
}}

\item{\code{matObj(raw = FALSE, transpose = FALSE)}}{\preformatted{
Retrieves the underlying Matrix for this object. Parameters:
      raw - Default FALSE, in which case the filtered Matrix (held in field
            'matrixUse') will be returned, if it is available. If not
            available, or if raw is TRUE, then the raw (as loaded from file)
            Matrix will be returned.
 transpose - Default FALSE. If true, the matrix will be transposed and names
            will be transfered to the appropriate dimensions
}}

\item{\code{metadata(id = NULL, key = NULL, na.rm = TRUE, drop = TRUE,
  verbose = TRUE)}}{\preformatted{
Select metadata by id, key or both
         id - Optional vector of IDs to query. If not provided, all IDs
              will be returned. Bear in mind that the metadata holds both
              row and column IDs mixed together
        key - Optional vector of key/tag names, if not provided then all
              available ones will be returned.
      na.rm - Default TRUE, which will remove NA values from returned
              results. Does not apply when both id and key are specified.
       drop - Default TRUE. If FALSE, the return value will be a data.table
              If TRUE, and zero or one metadata columns are present, then
              a named vector is returned.
    verbose - Default TRUE, which will warn about certain issues
}}

\item{\code{metadata_keys(id = NULL, key = NULL)}}{\preformatted{
Returns a character vector of metadata key names (eg 'Description')
}}

\item{\code{nnZero(obj = NULL, ...)}}{\preformatted{
Return the count of non-zero elements in the matrix. This is essentially
the number of 'live connections' currently stored.
cell
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well (so you can select the raw matrix if
              desired)
}}

\item{\code{populatedColumns(obj = NULL, ...)}}{\preformatted{
Return a logical vector indicating which columns have at least one non-zero
 cell
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well (so you can select the raw matrix if
              desired)
}}

\item{\code{populatedRows(obj = NULL, ...)}}{\preformatted{
Return a logical vector indicating which rows have at least one non-zero
cell
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well (so you can select the raw matrix if
              desired)
}}

\item{\code{rCounts(obj = NULL, ...)}}{\preformatted{
Return an integer vector of non-zero columns for each row
        obj - Default NULL, which will recover the matrix from matObj(),
              passing ... as well (so you can select the raw matrix if
              desired)
}}

\item{\code{removeEmpty(reason = NA)}}{\preformatted{
Remove all empty rows and columns. Invisibly returns a vector of removed IDs.
     reason - Default NA; If specified, a text value that will be added to
              the $filterLog under the 'reason' column
}}

\item{\code{removeEmptyColumns(reason = NA)}}{\preformatted{
Remove all empty columns (those that only contain zeros). Invisibly
returns a vector of removed IDs.
     reason - Default NA; If specified, a text value that will be added
              to the $filterLog under the 'reason' column
}}

\item{\code{removeEmptyRows(reason = NA)}}{\preformatted{
Remove all empty rows (those that only contain zeros). Invisibly returns a
vector of removed IDs.
     reason - Default NA; If specified, a text value that will be added to
              the $filterLog under the 'reason' column
}}

\item{\code{reset(asFactor = FALSE)}}{\preformatted{
Reset any filters that were applied - the 'used' matrix will be the
original 'raw' one
}}

\item{\code{rNames(raw = FALSE)}}{\preformatted{
Returns the row names of the Matrix
      raw - Default FALSE, in which case the filtered Matrix (held in field
            'matrixUse') will be used, if available - otherwise the original
            raw matrix will be used.
}}

\item{\code{show(...)}}{\preformatted{
A wrapper for showText(). Will be auto-invoked if an EventLogger
object is evaluated in the shell, UNLESS the object has a higher-
precedence show() function of its own. In that case, use showLog()
to display log contents.
}}
}}

\examples{

## Load a toy symbol-to-gene mapping matrix and use it to convert
## some genes to Entrez Gene IDs
demo("geneSymbolMapping", package="AnnotatedMatrix", ask=FALSE)

## Work with different file formats
demo("fileFormats", package="AnnotatedMatrix", ask=FALSE)

## Different approaches to handling non-unique mappings:
demo("managingMultiplicity", package="AnnotatedMatrix", ask=FALSE)

## Working with metadata
demo("workingWithMetadata", package="AnnotatedMatrix", ask=FALSE)

}
