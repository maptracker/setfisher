% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MethodsDocumentation.R
\name{map}
\alias{map}
\title{Map}
\arguments{
\item{input}{Default NULL. The method requires input to
function. It can be provided here as a character vector of IDs,
or if \code{append.to} has provided a data.frame, then it will
be taken from the column in that object specified by
\code{append.col}}

\item{via}{The matrix dimension that \code{input} is from. The
default is NULL, which will compare your input to both rows and
columns, and chose the dimension with the most matches
(defaulting to 'row' in the event of equal matches)}

\item{format}{Default 'data.frame', specifies the output
format. Can also be 'vector', which will return a named
character vector, with values corresponding to \code{$Output}
and names as \code{$Input}. A value of 'dynamictable' will
render the results as an interactive HTML table (requires
package 'dynamictable').}

\item{ignore.case}{Default TRUE, which ignores the capitilazation
of IDs in both columns and rows}

\item{keep.best}{Default FALSE. If TRUE, then only the top-scored
cell(s) will be kept for each input conversion}

\item{column.func}{Default \code{max}.  If ignore.case is true, it
is possible that an input ID can match multiple matrix IDs. In
this case, multiple matching rows will be returned for one
ID. \code{column.func} is applied to reduce this to a single
row. The function should accept a numeric vector of scores as
the first argument.}

\item{collapse}{Default NULL, which will cause every pairwise
connection to be reported. If 'in', then the \code{$Input}
column of the data.frame will be unique - any input value that
results in multiple output values will result in the
\code{$Output} IDs and \code{$Score} being 'collapsed' to a
single value (see the \code{collapse.*} options below). A value
of 'out' will do the same, but causes the \code{$Output} column
to be unique, and \code{$Input} and \code{$Score} are
collapsed.}

\item{collapse.name}{Default NULL, which will cause multiple names
to be concatenated into a single value using
paste(). Alternatively, a user function can be provided. This
package also includes the crude utility function
\link{takeLowestThing} which can be used here. The function
should accept a character vector of names as the first
argument.}

\item{collapse.token}{Default ',', a string used to concatenate
collapsed IDs when using paste via \code{collapse.name=NULL}.
An error will be thrown if it is not a single scalar string.}

\item{collapse.score}{Default NULL. Optional function to apply to
the \code{$Score} column when two or more rows are being
collapsed into one. The function should take a numeric vector
as input and return a single numeric value. If NULL, the
function will be mean(), unless the matrix is a pseudo-factor,
in which case the object method \link{.autoLevel} will be
used. This will generate new 'hybrid' factors as
needed. \code{collapse.token} will be used as the string to
join factors into a new level name.}

\item{integer.factor}{Default NULL, which will include both the
\code{$Score} column (integer factor value) as well as a
\code{$Factor} column (with level values as characters) in the
output to be present instead. If TRUE then ONLY a \code{$Score}
column (representing integer values, perhaps including new and
likely-meaningless hybrid values from \link{.autoLevel}) will
be added. If FALSE, then only the \code{$Factor} column will be
present.}

\item{add.metadata}{Default TRUE, which will add all metadata
columns that have at least some information associated with the
\code{$Ouput} column. FALSE will prevent adding metadata, and a
character vector will add those specific columns (it is up to
the user to confirm that requested columns exist in the
metadata store)}

\item{input.metadata}{Default FALSE. If true, then metadata columns
will also be included for the input IDs.}

\item{warn}{Default TRUE, which will show warning text if matches
failed to be made for the input. This information is also
always captured in attributes attached to the returned
data.frame}

\item{append.to}{Default NULL. If a data.frame-compliant object, it
will become the return value, with the columns generated by
this function being added on. If \code{collapse='out'} then the
\code{$Output} column will be used to merge, otherwise the
\code{$Input} column will be utilized. The merge column from
the provided data.frame is set with \code{append.col}}

\item{append.col}{The column to use in \code{append.to} for
merging. Default is \code{1L}, can provide another column
number or name. If \code{input} was not specified, then the
contents of this column will be taken as input.}

\item{recurse}{Default 0. This option is only relevant when the
identifiers on both rows and columns are the same, or at least
have significant overlap. If true, discovered Output IDs will
be re-mapped as Input IDs to discover more Output IDs,
recursively repeated the indicated number of times or until no
new IDs are found. The intended use case is to exhaustively
expand a Parent-Child network, either following parents "up" to
the root nodes, or following children down to transitively
discover all inherited child nodes.}

\item{in.name}{Default "Input". The header name to use for the
input IDs. If set to NULL, will be taken from the matrix
dimension name corresponding to the input.}

\item{out.name}{Default "Output". As per \code{in.name}, but for
the Output data.}

\item{score.name}{Default \code{NULL}. The column header for the
Score column. Can be set explicitly with a non-null
value. Otherwise, if the 'celldim' object parameter has been
set, that value will be used. If not, the "Score" will be
utilized.}

\item{prefix.metadata}{Default TRUE, which will prefix metadata
column headers with \code{out.name} and \code{in.name}, as
relevant.}

\item{help}{Default FALSE. If TRUE, show this help and perform no
other actions.}
}
\value{
If \code{format} is 'data.frame', a data.frame. If
    \code{format} is 'vector', an SVG map of the globe, with output
    values represented as minor bodies of water or occasionally
    rivers. Just kidding, you'd get a (named) vector.
}
\description{
AnnotatedMatrix object method to convert names on one dimension to the other
}
\details{
\preformatted{
## Method Usage:
myObject$map( help=TRUE )

myObject$map(input=NULL, via=NULL, format="data.frame", ignore.case=TRUE,
             keep.best=FALSE, column.func=max, collapse=NULL,
             collapse.name=NULL, collapse.token=',',
             collapse.score=NULL, collapse.factor=NULL,
             integer.factor=FALSE, add.metadata=TRUE,
             input.metadata=FALSE, warn=TRUE,
             append.to=NULL, append.col=1L,
             in.name="Input", out.name="Output", score.name=NULL,
             prefix.metadata=TRUE,
             help=FALSE )
}

This is the primary method for AnnotatedMatrix. It takes the input,
matches it to one of the dimensions (chosen either automatically or
specifically) and then reports "connections" to the other
dimension. The results can be returned in a variety of formats.

The method is alert for any non-unique mappings, and will record
such cases in attributes of the returned value as well as by alert
to the terminal. The following non-unique categories are noted:

\preformatted{
 Dup.In   : IDs that were present twice or more in input
            (possibly after case removal)
 Dup.Mat  : IDs that were present twice or more in matrix
            (always after case removal, since matrix names are unique)
 Mult.In  : Input IDs that generated multiple output values
 Mult.Out : Output IDs that were generated from multiple inputs
 Unmapped : Input ID is also in the matrix, but does not have a target
            with non-zero score. Score will be zero
 Unknown  : Input ID could not be matched to any in the matrix. Score
            will be \code{NA}
}

These categories also correspond to attributes of the same names
that are attached to the returned value. In addition, a "Notes"
attributes contains the above descriptions to aid in remembering
the distinctions between categories.

Note also that there are two "not mapped" scores. \code{NA}
indicates that the requested input value was not found in the
matrix, either because it was never there at all, or because the
row/col that held it was removed (through \link{removeEmpty} or
\link{rNames} / \link{cNames}). Alternatively, a value of \code{0}
indicates that the name is recognized, but now occupies a fully
zeroed-out row or column (presumably through applied
filters). These two distinct values can be helpful in
troubleshooting why some input values are not producing output.
}
\examples{

s2e <- AnnotatedMatrix( annotatedMatrixExampleFile() )

# I have some gene symbols, what Entrez Gene IDs do they map to?
syms <- c("FOXD3", "NBP", "AR")
s2e$map( syms )

# More messy than I wanted, "NBP" and "AR" are not uniquely
# mapping. Let's filter the matrix to only include official symbols
s2e$filterByFactorLevel("Official", keep=TRUE)
s2e$map( syms )

# Now we've lost mappings to NBP. Let's try again, but now use keep.best
s2e$reset() # Clear the filters (will also clear an automatic filter)
s2e$map( syms, keep.best=TRUE )

# The two NBP mappings are both unofficial. We could work with the
# data as-is, or we could collapse on input to assure that each row
# is unique:
s2e$map( syms, keep.best=TRUE, collapse='in' )

# We can also merge these data into an existing structure. Say we
# have some gene-linked research data:
evilCRO <- data.frame(
     Client=c("Evil Inc.", "Quite Evil", "Totally Evil"),
     Mutation=c("FOXD3", "NBP", "AR"),
     Phenotype=c("Eye lasers", "Adamantine claws", "Bunny whiskers"),
     Contained=c(TRUE,TRUE,FALSE),
     stringsAsFactors=FALSE)

# We can generate an integrated data.frame with append.to. Don't
# forget to specify the merge column with append.col if it's not
# the first column.
evilLoci <- s2e$map(append.to=evilCRO, append.col="Mutation",
                    keep.best=TRUE, collapse='in' )
evilLoci

# For large results the non-unique events may not be
# transparent. Check the attributes to identify non-unique IDs
attr(evilLoci, 'Mult.In')

}
\seealso{
\link{.autoLevel}, \link{metadata}
}
